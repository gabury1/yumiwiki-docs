---
title: 캐싱
aliases: ["caching", "cache", "캐시"]
---

# 캐싱

> 자주 사용하는 데이터를 빠르게 제공하는 방식

원본 데이터를 빠른 저장소에 복사해두고, 다음 요청 시 원본 대신 복사본을 제공하는 방식이다. 자주 보는 책을 서가에서 책상 위로 꺼내두는 것과 같다.

## 동작 원리

요청이 들어오면 먼저 캐시를 확인한다. 있으면(Cache Hit) 바로 반환. 없으면(Cache Miss) 원본에서 가져와서 캐시에 저장 후 반환. 다음에 같은 요청이 오면 캐시에서 빠르게 제공.

캐시는 보통 메모리에 있어서 디스크나 네트워크보다 훨씬 빠르다. [[Redis]]는 마이크로초 단위, DB는 밀리초 단위.

## 용도

웹 서비스에서 DB 쿼리 결과를 캐싱해서 응답 속도를 높인다. [[CDN]]에서 정적 파일을 전 세계에 캐싱. 브라우저에서 이미지, JS, CSS를 로컬에 캐싱.

## 장단점

**장점**: 응답 속도 향상, 원본 시스템 부하 감소, 비용 절감

**단점**: 데이터 일관성 문제 (캐시와 원본이 다를 수 있음), 캐시 무효화 복잡, 메모리 비용

## 주의점

**캐시 무효화**: "컴퓨터 과학에서 어려운 것 두 가지: 캐시 무효화와 이름 짓기". TTL 설정, 명시적 삭제 등 전략 필요.

**Cache Stampede**: 캐시 만료 시 동시 요청이 원본으로 몰림. 락이나 확률적 갱신으로 방지.

## 생태계

- [[Redis]] - 인메모리 캐시 서버
- [[Memcached]] - 단순 키-값 캐시
- [[CDN]] - 정적 콘텐츠 엣지 캐싱
- [[Varnish]] - HTTP 캐시 프록시

## 기타

"컴퓨터 과학에서 어려운 것 두 가지: 캐시 무효화와 이름 짓기"라는 유명한 농담이 있다. Phil Karlton이 한 말인데, 실제로 캐시를 언제 지울지 결정하는 게 생각보다 까다롭다. 너무 자주 지우면 캐시 의미가 없고, 너무 안 지우면 오래된 데이터를 보여준다.

브라우저 캐시 때문에 삽질한 경험은 거의 모든 웹 개발자가 있다. CSS 수정했는데 브라우저가 옛날 파일을 보여줘서 "왜 안 바뀌지?" 하다가, Ctrl+F5로 강제 새로고침해서 해결하는 패턴. 그래서 버전 쿼리 스트링(`style.css?v=2`)을 붙이는 게 일반적이다.

CPU 캐시는 프로그래머가 직접 제어할 수 없지만, 성능에 엄청난 영향을 준다. 캐시 친화적인 코드와 그렇지 않은 코드의 속도 차이가 10배 이상 날 수 있다. 배열을 순차적으로 순회하는 게 랜덤 접근보다 빠른 이유가 캐시 적중률 때문이다.

"캐시는 만병통치약"이라는 농담도 있다. 성능 문제가 생기면 일단 "캐시를 써보자"는 얘기가 나온다. 실제로 많은 경우에 효과적이지만, 근본 원인 해결 없이 캐시로만 때우면 나중에 더 큰 문제가 생긴다.
