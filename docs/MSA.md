---
title: MSA
aliases: ["microservices", "msa", "마이크로서비스", "마이크로서비스구조"]
---

# MSA (Microservices Architecture)

> 거대한 성을 작은 마을들로 쪼개다

하나의 거대한 애플리케이션(Monolithic)을 작고 독립적인 여러 개의 서비스로 쪼개서 개발하고 배포하는 아키텍처 스타일. 넷플릭스, 아마존 같은 빅테크 기업들이 유행시켰다.

## 특징

**서비스 분리**: "회원 서비스", "주문 서비스", "결제 서비스"가 각각 별도의 서버, 별도의 DB를 쓸 수도 있다.

**독립 배포**: 주문 서비스만 고쳤으면 주문 서비스만 배포하면 된다. 전체 시스템을 셧다운할 필요가 없다.

**폴리글랏(Polyglot)**: 회원 서비스는 [[Java]], 머신러닝 서비스는 [[Python]], 실시간 채팅은 [[Node.js]]로 만들어도 된다. 서비스 간 통신만 맞추면 된다.

## 통신 방식

서비스끼리 대화하는 방법이 중요하다.
- **동기(Synchronous)**: [[REST]] API, [[gRPC]]. (응답을 기다림)
- **비동기(Asynchronous)**: [[Kafka]], [[RabbitMQ]] 같은 메시지 큐 사용. (이벤트만 던지고 빠짐)

## 장점 vs 단점

### 장점
- **[[확장성]]**: 주문량만 폭증하면 주문 서비스만 서버를 늘리면 된다.
- **유연성**: 팀별로 다른 기술 스택을 도입하기 쉽다.
- **복원력**: 결제 서비스가 죽어도 상품 구경(조회 서비스)은 할 수 있다.

### 단점
- **복잡도**: 관리해야 할 서버가 수백 개로 늘어난다. [[Kubernetes]]나 [[Docker]] 없이는 운영 불가능.
- **데이터 일관성**: DB가 쪼개져 있어서 `JOIN`을 못 쓴다. 분산 트랜잭션(Saga 패턴 등)이 필요하다.
- **네트워크 비용**: 함수 호출이 아니라 네트워크 통신이라 느릴 수 있다.

## 기타

"MSA는 은탄환이 아니다". 스타트업 초기에는 모놀리식으로 빠르게 개발하고, 트래픽이 감당 안 될 때 점진적으로 MSA로 전환하는 것이 정석이다(Monolith First). 마틴 파울러도 "MSA 하지 마라(Don't do it)"부터 고려하라고 했다.
