---
aliases: [JSON Web Token, jwt]
---

# JWT

> 당사자 간 정보를 안전하게 전송하기 위한 토큰 표준

JSON 형식의 데이터를 서명해서 토큰으로 만든 것이다. [[인증]] 정보를 담아서 클라이언트-서버 간 주고받는다. 세션 대신 무상태 인증에 사용.

## 탄생 배경

세션 기반 인증은 서버가 상태를 저장해야 했다. 서버가 여러 대면 세션 공유 문제 발생. 토큰에 정보를 담아서 서버가 상태 없이 검증할 수 있게 됐다.

## 규정 내용

**구조**: `Header.Payload.Signature`

- **Header**: 토큰 타입, 서명 알고리즘 (HS256, RS256 등)
- **Payload**: 담고 싶은 데이터 (Claims). 사용자 ID, 만료 시간 등
- **Signature**: Header + Payload를 비밀키로 서명

**Base64URL로 인코딩**해서 URL에 담기 안전.

서버는 Signature를 검증해서 토큰이 변조되지 않았음을 확인.

## 용도

로그인 후 발급받아서 요청마다 `Authorization: Bearer {token}` 헤더에 담아 보냄. 서버는 DB 조회 없이 토큰만으로 인증 가능.

## 주의점

**탈취 위험**: 토큰 훔치면 끝. HTTPS 필수, 만료 시간 짧게.

**무효화 어려움**: 서버가 상태 없으니 로그아웃해도 토큰 여전히 유효. 블랙리스트 관리하거나 짧은 만료 + Refresh Token 조합.

**Payload는 암호화 아님**: 서명만 됨. 민감 정보 넣지 말 것.

## 생태계

- [[OAuth2]] - JWT를 Access Token으로 사용
- [[Auth0]], [[Firebase Auth]] - 인증 서비스
- 대부분의 웹 프레임워크에 JWT 라이브러리 있음

## 기타

JWT는 2015년 IETF RFC 7519로 표준화됐다. 세션 방식의 확장성 문제를 해결하려는 필요에서 나왔다. [[마이크로서비스]] 아키텍처가 유행하면서 더 주목받았다. 서비스마다 세션 공유할 필요 없이 토큰만으로 인증되니까.

Base64URL로 인코딩되어서 "암호화된 거 아니야?"라고 착각하기 쉽다. 하지만 인코딩은 암호화가 아니다. 누구나 디코딩해서 Payload를 볼 수 있다. jwt.io 같은 사이트에 붙여넣으면 바로 보인다. 그래서 비밀번호, 개인정보 넣으면 안 된다.

"JWT는 쿠키에 저장할까, localStorage에 저장할까" 논쟁이 있다. 쿠키는 XSS에 약하지만 HttpOnly 설정하면 안전. localStorage는 CSRF에는 강하지만 XSS에 취약. 정답은 없고, 상황에 따라 선택. 요즘은 HttpOnly 쿠키 + CSRF 토큰 조합을 많이 쓴다.

"Refresh Token" 패턴이 일반적이다. Access Token은 짧게(15분), Refresh Token은 길게(2주). Access Token 만료되면 Refresh Token으로 재발급. 탈취당해도 피해를 최소화하는 전략. [[OAuth2]]에서도 이 패턴을 쓴다.
