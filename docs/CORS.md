---
title: CORS
aliases: ["cors", "cross-origin resource sharing", "교차출처리소스공유", "코즈"]
---

# CORS (Cross-Origin Resource Sharing)

> "저기요, 우리 아는 사이인가요?" - 브라우저의 보안 문지기

웹 개발자라면 반드시 한 번은 마주하며, 십중팔구 짜증을 내게 만드는 **브라우저 보안 정책**이다. 한 출처(Origin)에서 실행 중인 웹 애플리케이션이, **다른 출처**의 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제다.

## 출처(Origin)란?

다음 3가지가 하나라도 다르면 "남"이다.
1. **프로토콜** (`http` vs `https`)
2. **도메인** (`naver.com` vs `google.com`)
3. **포트** (`:8080` vs `:3000`)

예: `http://localhost:3000`에서 `http://localhost:8080`으로 요청을 보내면 **CORS 위반**이다. (포트가 다르니까!)

## 왜 필요한가? (보안)

만약 CORS가 없다면 어떻게 될까?
내가 악성 사이트 `evil.com`에 접속했는데, 그 사이트에 심어진 [[JavaScript]]가 내 브라우저에 남은 쿠키를 이용해 `naver.com`에 몰래 로그인하고 내 정보를 빼갈 수 있다 (**SOP: Same Origin Policy**). CORS는 "우리가 허락한 사이트만 정보를 가져가게 해줄게"라는 안전장치다.

## 작동 방식 (Preflight 요청)

브라우저는 다른 곳에 요청을 보내기 전에, 먼저 가벼운 탐색용 요청(**OPTIONS**)을 보낸다.
1.  **브라우저**: "야, `localhost:8080` 너 혹시 `localhost:3000`한테 데이터 줄 생각 있어?" (Preflight)
2.  **서버**: "응, 걔는 내가 허락한 애야. `Access-Control-Allow-Origin: localhost:3000`이라고 응답에 적어줄게."
3.  **브라우저**: "오케이, 그럼 진짜 요청(GET, POST) 보낼게."

## 해결 방법

1.  **서버에서 허용**: 가장 정석. 백엔드 코드([[Spring Boot]], [[Express]] 등)에서 허용할 도메인을 설정한다.
2.  **프록시(Proxy) 서버**: 브라우저를 속이는 방식. 개발 시에 [[Vite]]나 [[Webpack]]에서 `proxy` 설정을 하면 된다.
3.  **[[Nginx]] 설정**: 리버스 프록시 단에서 헤더를 붙여준다.

## 기타

1.  **서버는 죄가 없다**: 사실 서버는 요청을 잘 처리한다. 다만 브라우저가 응답을 받고 "어? 이거 남이 보낸 건데?" 하고 차단해버리는 것이다. 즉, CORS는 **브라우저의 고집**이다.
2.  **Postman에선 되는데요?**: 포스트맨이나 CLI([[curl]])는 브라우저가 아니기 때문에 CORS 정책이 적용되지 않는다. 여기서 된다고 브라우저에서 잘될 거라 믿으면 안 된다.
3.  **허용(*)의 유혹**: "에라 모르겠다" 하고 모든 도메인을 허용(`Access-Control-Allow-Origin: *`)하면 보안이 뚫리니 개발할 때만 잠깐 쓰고 실무에선 절대 조심해야 한다.
