---
title: 지연 초기화
aliases: ["lazy initialization", "lazy loading", "레이지 로딩", "지연로딩"]
---

# 지연 초기화

변수나 객체를 선언 시점이 아니라 실제로 사용하는 시점에 초기화하는 기법이다.

## 하는 이유?

### 1. 성능 최적화

무거운 객체를 미리 만들어두면 메모리와 시간이 낭비된다. 필요할 때만 만들면 효율적이다.

```kotlin
class Application {
    // 데이터베이스 연결은 시간이 오래 걸림
    val database by lazy {
        println("데이터베이스 연결 중... (3초 소요)")
        createHeavyDatabaseConnection()
    }
    
    // 캐시는 메모리를 많이 먹음
    val cache by lazy {
        println("100MB 캐시 생성 중...")
        createLargeCache()
    }
}

val app = Application()  // 여기서는 아무것도 안 만들어짐
// 앱 시작이 빠름!

app.database  // 실제로 DB 쓸 때만 연결
```

**실제 효과:**
- 앱 시작 시간 단축
- 메모리 사용량 감소
- 안 쓰는 기능은 아예 초기화 안 함

### 2. 의존성 문제 해결

초기화 시점에 필요한 것이 아직 준비되지 않았을 때가 있다.

```kotlin
class MyActivity : Activity() {
    // onCreate() 전에는 findViewById를 호출할 수 없음
    lateinit var textView: TextView
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // 여기서야 초기화 가능
        textView = findViewById(R.id.textView)
    }
}
```

**문제 상황:**
- Android의 View는 Activity가 생성된 후에만 접근 가능
- 테스트 프레임워크의 의존성은 `@Before`에서 주입
- 설정 파일은 앱 시작 후에 로드됨

**해결:** `lateinit`으로 "나중에 초기화할게"라고 약속하고, 준비되면 초기화한다.

### 3. 순환 참조 방지

두 객체가 서로를 참조할 때 생성 순서 문제가 발생한다.

```kotlin
class Parent {
    val child by lazy { Child(this) }  // Parent가 완전히 생성된 후 Child 생성
}

class Child(val parent: Parent)

// 일반 초기화였다면:
// Parent 생성 중 -> Child 생성 시도 -> Parent 참조 필요 -> 아직 생성 중! (에러)
```

### 4. 조건부 초기화

특정 조건에서만 객체가 필요할 때 유용하다.

```kotlin
class UserProfile(val isPremium: Boolean) {
    val premiumFeatures by lazy {
        if (isPremium) {
            loadPremiumFeatures()  // 프리미엄 유저만 로드
        } else {
            null
        }
    }
}
```

### 5. 비용이 큰 계산 지연

복잡한 계산 결과를 캐싱하면서 필요할 때만 계산한다.

```kotlin
class DataAnalyzer(val data: List<Int>) {
    val statistics by lazy {
        println("복잡한 통계 계산 중...")
        Statistics(
            mean = data.average(),
            median = data.sorted()[data.size / 2],
            stdDev = calculateStandardDeviation(data)
        )
    }
}

val analyzer = DataAnalyzer(hugeDataset)
// 통계가 필요 없으면 계산 안 함
if (needsStatistics) {
    println(analyzer.statistics)  // 이 순간 계산됨
}
```

## 기타

### 언어별 지원

거의 모든 현대 프로그래밍 언어가 지연 초기화를 지원한다.

**Kotlin**
```kotlin
val data by lazy { ExpensiveData() }
lateinit var view: View
```

**Swift**
```swift
lazy var data: ExpensiveData = {
    return ExpensiveData()
}()
```

**Python**
```python
from functools import cached_property

class MyClass:
    @cached_property
    def data(self):
        return ExpensiveData()
```

**C#**
```csharp
private Lazy<ExpensiveData> _data = new Lazy<ExpensiveData>();
public ExpensiveData Data => _data.Value;
```

**JavaScript**
```javascript
class MyClass {
    get data() {
        return this._data ??= new ExpensiveData();
    }
}
```

**Ruby**
```ruby
def data
  @data ||= ExpensiveData.new
end
```

**Java** (언어 차원 지원 없음, 수동 구현)
```java
private ExpensiveData data;

public ExpensiveData getData() {
    if (data == null) {
        data = new ExpensiveData();
    }
    return data;
}
```

### Kotlin의 lazy vs lateinit

| 특징 | `lazy` | `lateinit` |
|------|--------|-----------|
| 선언 | `val` | `var` |
| 초기화 | 자동 (첫 접근 시) | 수동 (직접 할당) |
| 타입 | 모든 타입 | non-null 참조 타입만 |
| 스레드 안전 | 기본적으로 안전 | 안전하지 않음 |
| 사용 시점 | 무거운 계산/객체 | 외부에서 주입되는 의존성 |

**lazy 예시:**
```kotlin
val database by lazy {
    createDatabase()  // 자동으로 첫 접근 시 실행
}
```

**lateinit 예시:**
```kotlin
lateinit var database: Database

fun setup() {
    database = createDatabase()  // 직접 할당 필요
}
```

### 주의사항

**1. lateinit 초기화 확인**
```kotlin
lateinit var data: Data

if (::data.isInitialized) {
    data.use()
} else {
    println("아직 초기화 안 됨")
}
```

**2. lazy 스레드 안전 모드**
```kotlin
// 기본: 스레드 안전 (느림)
val data by lazy { ExpensiveData() }

// 스레드 안전 불필요 (빠름)
val data by lazy(LazyThreadSafetyMode.NONE) { ExpensiveData() }

// 발행-구독 패턴 (중간)
val data by lazy(LazyThreadSafetyMode.PUBLICATION) { ExpensiveData() }
```

**3. lateinit 제약사항**
```kotlin
// ❌ primitive 타입 불가
lateinit var count: Int  // 컴파일 에러

// ❌ nullable 타입 불가
lateinit var name: String?  // 컴파일 에러

// ✅ 참조 타입만 가능
lateinit var user: User  // OK
```

### 실전 패턴

**싱글톤 패턴**
```kotlin
object DatabaseManager {
    val connection by lazy {
        createDatabaseConnection()
    }
}
```

**Android ViewModel**
```kotlin
class MyViewModel : ViewModel() {
    val userData by lazy {
        repository.loadUserData()
    }
}
```

**테스트 코드**
```kotlin
class MyTest {
    lateinit var mockService: MockService
    
    @Before
    fun setup() {
        mockService = MockService()
    }
    
    @Test
    fun test() {
        mockService.doSomething()
    }
}
```

**설정 로딩**
```kotlin
class AppConfig {
    val settings by lazy {
        loadSettingsFromFile()
    }
}
```

### 성능 비교

```kotlin
// 즉시 초기화: 앱 시작 시 모두 생성
class App {
    val feature1 = HeavyFeature1()  // 1초
    val feature2 = HeavyFeature2()  // 1초
    val feature3 = HeavyFeature3()  // 1초
}
// 앱 시작: 3초 소요

// 지연 초기화: 필요할 때만 생성
class App {
    val feature1 by lazy { HeavyFeature1() }
    val feature2 by lazy { HeavyFeature2() }
    val feature3 by lazy { HeavyFeature3() }
}
// 앱 시작: 0초
// feature1 사용 시: 1초
// feature2 안 쓰면: 생성 안 함!
```

### 안티패턴

**너무 많이 쓰지 마라**
```kotlin
// ❌ 간단한 값까지 lazy로 만들 필요 없음
val name by lazy { "John" }  // 오버킬

// ✅ 그냥 바로 할당
val name = "John"
```

**lateinit 남용**
```kotlin
// ❌ nullable로 해결 가능한데 lateinit 쓰기
lateinit var optionalData: Data

// ✅ nullable 사용
var optionalData: Data? = null
```

지연 초기화는 강력한 도구지만, 필요할 때만 쓰는 게 중요하다. "무거운 것", "나중에 준비되는 것"에만 적용하자.
