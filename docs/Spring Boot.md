---
title: Spring Boot
aliases: ["spring", "springboot", "spring boot", "스프링", "스프링부트"]
---

# Spring Boot

> 엔터프라이즈급 [[Java]] 백엔드를 빠르게 만들고 싶을 때

[[Java]] 기반 [[웹 프레임워크]]다. [[Spring Framework]]를 더 쉽게 쓸 수 있도록 감싼 프레임워크로, 복잡한 XML 설정 없이 어노테이션 기반으로 개발할 수 있다.

대기업, 금융권, 공공기관에서 압도적으로 많이 쓴다. 국내 SI 시장의 80% 이상이 Spring 기반이라고 봐도 무방하다. 안정성과 성능이 수십 년간 검증된 기술이라 대규모 트래픽, 복잡한 비즈니스 로직, 트랜잭션 처리가 많은 서비스에 적합하다. 쿠팡, 배달의민족, 토스 같은 대형 서비스들도 핵심 백엔드는 Spring Boot다.

[[Java]]나 [[Kotlin]]을 이미 알고 있다면 러닝커브가 완만한 편이다. 반면 [[Python]]이나 [[JavaScript]]만 해본 사람이라면 처음에 좀 무겁게 느껴질 수 있다. 객체지향 설계, [[DI|의존성 주입]], [[AOP]] 같은 개념을 이해해야 제대로 쓸 수 있다. 설정할 게 많아 보이지만, 요즘은 Spring Initializr로 프로젝트 생성하면 대부분 자동으로 잡혀서 예전만큼 복잡하지 않다.

솔직히 소규모 프로젝트나 MVP에는 오버스펙이다. 빠르게 뭔가 만들어야 할 때는 [[Django]]나 [[Express]]가 나을 수 있다. 하지만 서비스가 커지면 Spring Boot의 구조화된 아키텍처가 빛을 발한다. 처음부터 구조를 잘 잡아두면 10년 넘게 유지보수하는 것도 가능하다.

## 성능

[[JVM]] 위에서 돌아가서 초기 구동 시간이 좀 걸린다. 콜드 스타트가 2~5초 정도. [[서버리스]] 환경이나 [[Kubernetes]]에서 빠른 스케일링이 필요한 경우 이게 단점이 될 수 있다.

메모리는 기본으로 300~500MB 정도 잡아먹는다. 복잡한 애플리케이션은 1GB 이상 필요한 경우도 많다. 하지만 일단 뜨고 나면 [[JIT 컴파일러]] 덕에 성능이 꽤 좋다. 워밍업 후에는 [[Go]]나 [[Rust]] 같은 네이티브 언어에 근접하는 성능을 낸다.

동시 접속 처리도 잘 하고, [[멀티스레딩]]을 잘 활용하면 CPU 바운드 작업도 효율적으로 처리 가능하다. [[Tomcat]] 기본 설정으로도 동시 200개 커넥션은 무리 없이 처리한다. [[WebFlux]]를 쓰면 [[리액티브 프로그래밍]]으로 더 높은 처리량을 낼 수 있다.

Spring Boot 3부터 [[GraalVM]] 네이티브 이미지를 지원해서 콜드 스타트 문제를 해결할 수 있다. 시작 시간 0.1초, 메모리 50MB까지 줄일 수 있다. 다만 빌드 시간이 5~10분으로 오래 걸리고, 리플렉션 쓰는 라이브러리는 추가 설정이 필요하다.

## 생태계

[[Spring Security]]로 인증/인가, [[Spring Data]]로 DB 접근, [[Spring Cloud]]로 [[마이크로서비스]], [[Spring Batch]]로 대용량 배치 처리. 웬만한 기능은 Spring 생태계 안에서 해결된다. 공식 프로젝트만 20개가 넘는다.

[[Maven]]이나 [[Gradle]]로 의존성 관리하고, [[JPA]], [[MyBatis]], [[jOOQ]] 같은 [[ORM]]도 자유롭게 선택 가능. [[Lombok]]으로 보일러플레이트 줄이고, [[MapStruct]]로 DTO 변환 자동화하는 게 일반적이다.

한국어 자료가 엄청 많다. 인프런, 유데미에 강의도 많고, 책도 많이 나와있다. 취업 시장에서 백엔드 개발자 채용 공고의 절반 이상이 Spring 경험을 요구한다. 커뮤니티도 활성화되어 있어서 막히면 검색으로 거의 해결된다.

## 주의점

**N+1 쿼리 문제**: [[JPA]] 쓸 때 가장 흔한 실수. 연관 엔티티를 조회할 때 쿼리가 N번 추가로 발생한다. `@EntityGraph`, `fetch join`, `@BatchSize`로 해결해야 한다. 이거 모르고 쓰면 DB가 터진다.

**트랜잭션 전파**: `@Transactional` 어노테이션의 propagation 옵션을 이해해야 한다. 기본값은 `REQUIRED`인데, 중첩 트랜잭션에서 예상과 다르게 동작할 수 있다. 특히 `REQUIRES_NEW`를 남발하면 데드락 걸리기 쉽다.

**순환 참조**: Bean 간에 서로 의존하면 애플리케이션이 안 뜬다. Spring Boot 2.6부터 기본적으로 막혀있다. 설계를 잘못한 신호니까 구조를 다시 생각해봐야 한다.

**프록시 이슈**: [[AOP]]가 프록시 기반이라 같은 클래스 내 메서드 호출은 `@Transactional`, `@Cacheable` 같은 어노테이션이 안 먹힌다. `self-invocation` 문제라고 한다. 외부에서 호출하거나 `AopContext.currentProxy()` 써야 한다.

**메모리 누수**: [[JPA]] 영속성 컨텍스트에 엔티티가 계속 쌓이면 메모리가 터진다. 배치 작업에서 `clear()` 안 하고 수만 건 처리하다 OOM 나는 경우가 많다. `@Modifying`으로 벌크 연산하거나 주기적으로 flush/clear 해줘야 한다.

**버전 호환성**: Spring Boot 메이저 버전 올릴 때 마이그레이션이 쉽지 않다. 특히 2.x에서 3.x 올릴 때 [[Jakarta EE]] 전환 때문에 패키지명이 `javax.*`에서 `jakarta.*`로 바뀐다. 의존 라이브러리들도 다 맞춰줘야 한다.

## 주요 기능

- [[IoC|제어의 역전]] / [[DI|의존성 주입]] 내장
- [[AOP|관점 지향 프로그래밍]] 지원
- 내장 [[Tomcat]] 서버 (Jetty, Undertow로 교체 가능)
- [[Actuator]]로 모니터링/헬스체크/메트릭 수집
- 자동 설정 (Auto Configuration)으로 보일러플레이트 최소화
- [[Spring Boot DevTools]]로 핫 리로드

## 기타

[[Spring Framework]]를 만든 Rod Johnson은 2002년에 "Expert One-on-One J2EE Design and Development"라는 책을 썼다. J2EE(당시 자바 엔터프라이즈 표준)가 너무 복잡하다고 비판하면서 더 나은 방법을 제시했고, 이게 Spring의 시작이었다.

Spring Boot는 2014년에 나왔다. Spring을 쓰려면 XML 설정 파일이 수백 줄씩 필요했는데, 이게 너무 불편하다는 불만이 많았다. "그냥 실행하면 되는 거 없어?"라는 질문에 대한 답이 Spring Boot다.

국내 개발자들 사이에서 "스프링은 프레임워크가 아니라 생태계"라는 말이 있다. 웬만한 기능은 Spring 안에서 다 해결되니까... 좋게 보면 통합 솔루션, 나쁘게 보면 vendor lock-in이다.

개발자 채용 시장에서 "Spring 3년 이상"이라는 조건이 많은데, 실제로는 Spring Boot 경험을 의미하는 경우가 대부분이다. 요즘 순수 Spring(Boot 없이)만 쓰는 프로젝트는 거의 없다.
