---
title: GraphQL
aliases: ["graphql", "gql", "그래프큐엘"]
---

# GraphQL (GQL)

> "원하는 데이터만 쏙쏙 골라 담으세요"

Facebook(Meta)이 만든 API용 쿼리 언어다. 기존의 [[REST]] 규칙이 가진 한계를 해결하기 위해 나왔다.

## 왜 필요한가? (식당 비유)

-   **REST (정식 코스)**: "불고기 정식 주세요"라고 하면 김치, 밥, 불고기가 세트로 나온다. 만약 불고기만 먹고 싶어도 다 받아야 한다 (**Over-fetching**). 혹은 양이 모자라 정식을 한 번 더 시켜야 한다 (**Under-fetching**).
-   **GraphQL (뷔페)**: "불고기 100g이랑 밥만 주세요"라고 내가 원하는 만큼, 원하는 종류만 정확히 요청한다.

## 특징

**One Endpoint**: `/users`, `/posts` 처럼 주소가 여러 개일 필요 없다. 단 하나의 주소(Endpoint)로 모든 요청을 보낸다.

**정확한 데이터**: 클라이언트가 쿼리에 적은 필드만 서버가 돌려준다. 모바일 환경에서 데이터 전송량을 획기적으로 줄여준다.

**강력한 타입**: Schema를 미리 정의하므로, 어떤 데이터가 오갈지 서버와 클라이언트가 확실히 알 수 있다. (문서화가 자동으로 된다)

## 작동 방식 (쿼리 예시)

```graphql
# 요청: 나 사용자의 이름이랑 친구들 이름만 줘
query {
  user(id: "1") {
    name
    friends {
      name
    }
  }
}
```

## 장점 vs 단점

### 장점
-   **효율**: 한 번의 요청으로 여러 리소스를 가져올 수 있다.
-   **유연성**: 프론트엔드가 필요한 데이터가 바뀌어도 백엔드를 수정할 필요가 거의 없다.

### 단점
-   **캐싱의 어려움**: HTTP 레벨의 캐싱([[캐싱]])을 쓰기 어렵다. (주소가 하나라서)
-   **학습 곡선**: [[REST]]보다 초기 설정과 개념 이해가 어렵다.
-   **서버 부하**: 클라이언트가 너무 복잡한 쿼리를 보내면 서버가 과부하 걸릴 수 있다.

## 기타

1.  **Graph일 뿐**: 이름에 Graph가 들어가지만 꼭 그래프 데이터베이스(Neo4j 등)를 써야 하는 건 아니다. 그냥 데이터 관계를 그래프로 표현할 뿐이다.
2.  **Apollo**: GraphQL 하면 짝꿍처럼 나오는 게 **Apollo Client/Server**다. 거의 표준처럼 쓰이는 라이브러리다.
3.  **대체재**: 최근에는 [[TypeScript]] 환경에서 타입 안전성을 극한으로 끌어올린 **tRPC** 같은 기술들이 경쟁자로 떠오르고 있다.
